#include <stdio.h>
#include <opencv2/opencv.hpp>
#include "opencv2/highgui.hpp"
#include "opencv2/imgcodecs.hpp"
#include "opencv2/imgproc.hpp"
#include <opencv2/core.hpp>
#include <iostream>
#include<map>
#include <vector>
#include <numeric>
#include <string>
#include <functional>
#include "LightSource.h"
#include "ImageProcessor.h"
#include "ImageParser.h"
#include "RenderingSimulator.h"
#include "Room.h"
//#include <QtPlugin>

//Q_IMPORT_PLUGIN(QWindowsIntegrationPlugin);

using namespace cv;


int main(int argc, char** argv )
{
	LightSource light("name of a file");
	ImageProcessor imageProcessor("name of a file");
	ImageParser imageParser("name of a file");
	Room room("name of a file");
	RenderingSimulator renderingSimulator("name of a file");

    if ( argc != 2 )
    {
        printf("usage: DisplayImage.out <Image_Path>\n");
        //return -1;
    }
    Mat image;
    //image = imread( argv[1], 1 );
	image = imread("C:/Users/brene/Documents/CapstoneProjectWithoutQt/Debug/move1.jpeg", IMREAD_GRAYSCALE);

	Mat image2;
	//image = imread( argv[1], 1 );
	image2 = imread("C:/Users/brene/Documents/CapstoneProjectWithoutQt/Debug/move2.jpeg", IMREAD_GRAYSCALE);

	//image = imread("tiger.jpg", IMREAD_GRAYSCALE);
	//image = imread("lena_color.jpg");
    if ( !image.data )
    {
        printf("No image data \n");
        return -1;
    }
	
    namedWindow("Display Image", WINDOW_NORMAL);
    imshow("Display Image", image);

	namedWindow("Display Image 2", WINDOW_NORMAL);
	imshow("Display Image 2", image2);

	Mat diffImage = image2 - image;
	Mat diffImageFloat;
	diffImage.convertTo(diffImageFloat, CV_32F);

	namedWindow("Diff image", WINDOW_NORMAL);
	imshow("Diff image", diffImage);

	//Mat diffImage2 = cv::Mat::zeros(diffImage.size().height, diffImage.size().width, CV_8UC1);
	Mat diffImage2 = cv::Mat::zeros(diffImage.size(), CV_32F);

	auto number = diffImage.at<char>(0, 0);
	 
	
	for (int i = 0; i < diffImage.size().height; i++)
	{
		for (int j = 0; j < diffImage.size().width; j++)
		{
			//diffImage2.at<char>(i, j) = diffImage.at<char>(i, j)*diffImage.at<char>(i, j);
			//diffImage2.at<float>(i, j) = diffImageFloat.at<float>(i, j)*diffImageFloat.at<float>(i, j);
			//diffImage2.at<float>(i, j) = sqrt(diffImageFloat.at<float>(i, j)*diffImageFloat.at<float>(i, j)/4);
			diffImage2.at<float>(i, j) = diffImageFloat.at<float>(i, j)*diffImageFloat.at<float>(i, j);
		}
	}

	auto num1 = diffImageFloat.at<float>(686, 711);
	//float num1f = static_cast<float>(num1);
	auto num2 = diffImage2.at<float>(686, 711);
	//float num2f = static_cast<float>(num2);
	//char num1char = static_cast<

	Mat diffImageChar;
	diffImage2.convertTo(diffImageChar, CV_8UC1);

	Mat diffImageThresholded;
	auto thresh = threshold(diffImageFloat, diffImageThresholded, 60, 255, 0);
	namedWindow("diffImageThresholded", WINDOW_NORMAL);
	imshow("diffImageThresholded", diffImageThresholded);

	//Mat contours;
	//Point2i point;
	//point.x = 686;
	//point.y = 711;
	//findContours(diffImageThresholded, contours, 3, 1);

	//namedWindow("contours", WINDOW_NORMAL);
	//imshow("contours", contours);


	Mat diffImageThresholdedChar;
	diffImageThresholded.convertTo(diffImageThresholdedChar, CV_8UC1);

	Mat canny_output;
	//int threshh = 40;
	Canny(diffImageChar, canny_output, thresh, thresh * 2);
	std::vector<std::vector<Point> > contours;
	std::vector<Vec4i> hierarchy;
	findContours(diffImageThresholdedChar, contours, hierarchy, RETR_TREE, CHAIN_APPROX_SIMPLE);

	Mat drawing = Mat::zeros(canny_output.size(), CV_8UC3);

	auto ii = contours.size();
	RNG rng(12345);
	std::map<size_t, std::vector<Point>> contoursSorted;

	for (int i = 0; i < contours.size(); i++)
	{
		//int sizeContour = contours.at(i).size();
		//TODO :: more robust algo, insert does not perform if the key is not unique, in case of contour of same size, the latter is not inserted in the map
		contoursSorted.emplace(contours.at(i).size(), contours.at(i));
	}

	std::vector<std::vector<Point> > contoursMovingInstances;
	std::vector<Point> barycentresContours;

	int numberMovingInstances = 2;
	for (int i = 0; i < numberMovingInstances; i++)
	{
		//contoursSorted.emplace(contours.at(i).size(), contours.at(i));
		//int indexCountour = static_cast<int>(contoursSorted.size()) - i;
		auto cont = prev(contoursSorted.end());
		auto stdp =	cont->second;
		contoursMovingInstances.emplace_back(stdp);
		contoursSorted.erase(prev(contoursSorted.end()));
	}

	  
	for (int i = 0; i < contoursMovingInstances.size(); i++)
	{
		Scalar color = Scalar(rng.uniform(0, 256), rng.uniform(0, 256), rng.uniform(0, 256));
		drawContours(drawing, contoursMovingInstances, (int)i, color, 2, LINE_8, hierarchy, 0);
		cv::Point zero(0, 0);
		Point sum = std::accumulate(contoursMovingInstances.at(i).begin(), contoursMovingInstances.at(i).end(), zero) / (static_cast<int>(contoursMovingInstances.at(i).size()));
		barycentresContours.emplace_back(sum);
	}

	Mat circleImage = Mat::zeros(canny_output.size(), CV_8UC3);
	circle(drawing, barycentresContours.at(0), 10, Scalar(150, 140, 150), 1, 8, 0);
	circle(drawing, barycentresContours.at(1), 20, Scalar(180, 40, 150), 1, 8, 0);
	namedWindow("CircleImageShow", WINDOW_NORMAL);
	imshow("CircleImageShow", circleImage);

	namedWindow("Contours", WINDOW_NORMAL);
	imshow("Contours", drawing);


	//Mat diffImagePow2;
	//pow(diffImage, 2, diffImage2);

	namedWindow("Pow", WINDOW_NORMAL);
	imshow("Pow", diffImage2);


	String window_name_blurred_with_3x3_kernel = "The Guitar Blurred with 3 x 3 Kernel";

	Mat image_blurred_with_3x3_kernel;
	blur(image, image_blurred_with_3x3_kernel, Size(3, 3));
	namedWindow(window_name_blurred_with_3x3_kernel, WINDOW_NORMAL);
	//imshow(window_name_blurred_with_3x3_kernel, image_blurred_with_3x3_kernel);


	//Mat src = imread("tiger.jpg");
	//Mat src = imread("C:/Users/brene/Documents/CapstoneProjectWithoutQt/Debug/fish.png");
	Mat src = imread("C:/Users/brene/Documents/CapstoneProjectWithoutQt/Debug/fishcrop.png");


	std::vector<Mat> bgr_planes;
	split(src, bgr_planes);
	int histSize = 256;
	float range[] = { 0, 256 }; //the upper boundary is exclusive
	const float* histRange = { range };
	bool uniform = true, accumulate = false;
	Mat b_hist, g_hist, r_hist;
	calcHist(&bgr_planes[0], 1, 0, Mat(), b_hist, 1, &histSize, &histRange, uniform, accumulate);
	calcHist(&bgr_planes[1], 1, 0, Mat(), g_hist, 1, &histSize, &histRange, uniform, accumulate);
	calcHist(&bgr_planes[2], 1, 0, Mat(), r_hist, 1, &histSize, &histRange, uniform, accumulate);
	int hist_w = 512, hist_h = 400;
	int bin_w = cvRound((double)hist_w / histSize);
	Mat histImage(hist_h, hist_w, CV_8UC3, Scalar(0, 0, 0));
	normalize(b_hist, b_hist, 0, histImage.rows, NORM_MINMAX, -1, Mat());
	normalize(g_hist, g_hist, 0, histImage.rows, NORM_MINMAX, -1, Mat());
	normalize(r_hist, r_hist, 0, histImage.rows, NORM_MINMAX, -1, Mat());
	for (int i = 1; i < histSize; i++)
	{
		line(histImage, Point(bin_w*(i - 1), hist_h - cvRound(b_hist.at<float>(i - 1))),
			Point(bin_w*(i), hist_h - cvRound(b_hist.at<float>(i))),
			Scalar(255, 0, 0), 2, 8, 0);
		line(histImage, Point(bin_w*(i - 1), hist_h - cvRound(g_hist.at<float>(i - 1))),
			Point(bin_w*(i), hist_h - cvRound(g_hist.at<float>(i))),
			Scalar(0, 255, 0), 2, 8, 0);
		line(histImage, Point(bin_w*(i - 1), hist_h - cvRound(r_hist.at<float>(i - 1))),
			Point(bin_w*(i), hist_h - cvRound(r_hist.at<float>(i))),
			Scalar(0, 0, 255), 2, 8, 0);
	}


	resizeWindow(window_name_blurred_with_3x3_kernel, 60, 60);

	imshow(window_name_blurred_with_3x3_kernel, src);
	//cv2.imshow("output", imS)
	imshow("calcHist Demo", histImage);

    waitKey(0);
    return 0;
}